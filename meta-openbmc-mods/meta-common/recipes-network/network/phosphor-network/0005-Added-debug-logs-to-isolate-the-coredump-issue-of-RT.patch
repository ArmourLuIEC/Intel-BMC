From f898e4512e7907ba185a1178ad36cb7af6ad0811 Mon Sep 17 00:00:00 2001
From: sureshv1 <suresh.vijayakumar@intel.com>
Date: Tue, 10 Aug 2021 16:38:42 +0530
Subject: [PATCH] Added Debug logs to isolate coredump of RTNETLink Packet
 Processing Clang Format updated

Tested:
Flashed the BMC firmware image with logs included and observed that
the logs are logged during the boot up time and not flooding serial
console.After the BMC is booted up, logs were logged in when ever a
RT Net Link Packet is received and not flooding the journalctl logs.

Change-Id: I5e1d152b18df17e5351c498210dae5c45f551f7b
Signed-off-by: sureshv1 <suresh.vijayakumar@intel.com>
---
 src/network_manager.cpp      | 15 ++++++++
 src/network_manager_main.cpp | 12 +++++++
 src/rtnetlink_server.cpp     | 70 ++++++++++++++++++++++++++++++++++++
 3 files changed, 97 insertions(+)

diff --git a/src/network_manager.cpp b/src/network_manager.cpp
index 2f5097a..ec48f2a 100644
--- a/src/network_manager.cpp
+++ b/src/network_manager.cpp
@@ -15,6 +15,7 @@
 #include <bitset>
 #include <filesystem>
 #include <fstream>
+#include <iostream>
 #include <map>
 #include <phosphor-logging/elog-errors.hpp>
 #include <phosphor-logging/log.hpp>
@@ -26,6 +27,8 @@ constexpr char SYSTEMD_PATH[] = "/org/freedesktop/systemd1";
 constexpr char SYSTEMD_INTERFACE[] = "org.freedesktop.systemd1.Manager";
 constexpr auto FirstBootFile = "/var/lib/network/firstBoot_";

+constexpr bool debug = true;
+
 namespace phosphor
 {
 namespace network
@@ -273,6 +276,12 @@ void Manager::createInterfaces()

 void Manager::createChildObjects()
 {
+    if (debug)
+    {
+        std::cout
+            << "Create Child Objects called(restart system conf and DHCP conf)"
+            << "\n";
+    }
     // creates the ethernet interface dbus object.
     createInterfaces();

@@ -289,6 +298,12 @@ void Manager::createChildObjects()
     objPath /= "dhcp";
     dhcpConf = std::make_unique<phosphor::network::dhcp::Configuration>(
         bus, objPath.string(), *this);
+
+    if (debug)
+    {
+        std::cout << "Create Child Objects Exiting"
+                  << "\n";
+    }
 }

 ObjectPath Manager::vlan(IntfName interfaceName, uint32_t id)
diff --git a/src/network_manager_main.cpp b/src/network_manager_main.cpp
index 983616f..c9bdb15 100644
--- a/src/network_manager_main.cpp
+++ b/src/network_manager_main.cpp
@@ -10,6 +10,7 @@
 #include <filesystem>
 #include <fstream>
 #include <functional>
+#include <iostream>
 #include <memory>
 #ifdef SYNC_MAC_FROM_INVENTORY
 #include <nlohmann/json.hpp>
@@ -41,6 +42,8 @@ constexpr auto configFile = "/usr/share/network/config.json";
 constexpr auto invNetworkIntf =
     "xyz.openbmc_project.Inventory.Item.NetworkInterface";

+constexpr bool debug = true;
+
 namespace phosphor
 {
 namespace network
@@ -255,10 +258,19 @@ void restartNetwork()

 void initializeTimers()
 {
+    if (debug)
+        std::cout
+            << "Initialize Timer for Refresh Object Timer and Restart Timer"
+            << "\n";
+
     auto event = sdeventplus::Event::get_default();
     refreshObjectTimer =
         std::make_unique<Timer>(event, std::bind(refreshObjects));
     restartTimer = std::make_unique<Timer>(event, std::bind(restartNetwork));
+
+    if (debug)
+        std::cout << "Initialize Timer Exiting"
+                  << "\n";
 }

 } // namespace network
diff --git a/src/rtnetlink_server.cpp b/src/rtnetlink_server.cpp
index 07ca08c..74f08b3 100644
--- a/src/rtnetlink_server.cpp
+++ b/src/rtnetlink_server.cpp
@@ -11,12 +11,15 @@
 #include <systemd/sd-daemon.h>
 #include <unistd.h>

+#include <iostream>
 #include <memory>
 #include <phosphor-logging/elog-errors.hpp>
 #include <phosphor-logging/log.hpp>
 #include <string_view>
 #include <xyz/openbmc_project/Common/error.hpp>

+constexpr bool debug = true;
+
 namespace phosphor
 {
 namespace network
@@ -29,6 +32,9 @@ namespace rtnetlink

 static bool shouldRefresh(const struct nlmsghdr& hdr, std::string_view data)
 {
+    if (debug)
+        std::cout << "Should Refresh the Received Header with Data"
+                  << "\n";
     switch (hdr.nlmsg_type)
     {
         case RTM_NEWADDR:
@@ -36,22 +42,43 @@ static bool shouldRefresh(const struct nlmsghdr& hdr, std::string_view data)
         case RTM_NEWROUTE:
         case RTM_DELROUTE:
         {
+            if (debug)
+                std::cout << "Don't Copy Data as the Message Type is:"
+                          << hdr.nlmsg_type << "\n";
             return true;
         }
         case RTM_NEWNEIGH:
         case RTM_DELNEIGH:
         {
+            if (debug)
+                std::cout << "Message Type is" << hdr.nlmsg_type << "\n";
             struct ndmsg ndm;
             if (data.size() < sizeof(ndm))
             {
+                if (debug)
+                    std::cout << "Data Size:" << data.size()
+                              << " NDM Size:" << sizeof(ndm) << "\n";
                 return false;
             }
+            if (debug)
+                std::cout
+                    << "Processing/Copying the received Data for MLMSG_TYPE:"
+                    << hdr.nlmsg_type << " Data Size:" << data.size() << "\n";
             memcpy(&ndm, data.data(), sizeof(ndm));
+            if (debug)
+                std::cout << "Copied the received Data for MLMSG_TYPE:"
+                          << hdr.nlmsg_type
+                          << " and NDM Message Size is:" << sizeof(ndm) << "\n";
             // We only want to refresh for static neighbors
             return ndm.ndm_state & NUD_PERMANENT;
         }
     }

+    if (debug)
+        std::cout << "Should Refresh Object is verified and done without any "
+                     "known header type"
+                  << "\n";
+
     return false;
 }

@@ -62,25 +89,58 @@ static int eventHandler(sd_event_source* /*es*/, int fd, uint32_t /*revents*/,
     char buffer[phosphor::network::rtnetlink::BUFSIZE]{};
     int len{};

+    if (debug)
+        std::cout << "\n"
+                  << "RTNETLINK event Handler is called to read the RTNETLINK "
+                     "Packet and Refresh it for a buffer size:"
+                  << phosphor::network::rtnetlink::BUFSIZE << "\n";
     auto netLinkHeader = reinterpret_cast<struct nlmsghdr*>(buffer);
     while ((len = recv(fd, netLinkHeader, phosphor::network::rtnetlink::BUFSIZE,
                        0)) > 0)
     {
+        if (debug)
+        {
+            std::cout << "Received the Packet with a Length:" << len << "\n";
+        }
         for (; (NLMSG_OK(netLinkHeader, len)) &&
                (netLinkHeader->nlmsg_type != NLMSG_DONE);
              netLinkHeader = NLMSG_NEXT(netLinkHeader, len))
         {
+            if (debug)
+                std::cout << "NetLinkHeader Message Type is:"
+                          << netLinkHeader->nlmsg_type
+                          << " with total length(len):" << len
+                          << " and block data packet "
+                             "length(netLinkHeader->nlmsg_len - NLMSG_HDRLEN):"
+                          << netLinkHeader->nlmsg_len - NLMSG_HDRLEN
+                          << " and Message Length(netLinkHeader->nlmsg_len):"
+                          << netLinkHeader->nlmsg_len << "\n";
             std::string_view data(
                 reinterpret_cast<const char*>(NLMSG_DATA(netLinkHeader)),
                 netLinkHeader->nlmsg_len - NLMSG_HDRLEN);
+            if (debug)
+            {
+                if (netLinkHeader)
+                    std::cout << "NetLinkHeader is valid"
+                              << "\n";
+            }
             if (shouldRefresh(*netLinkHeader, data))
             {
                 // starting the timer here to make sure that we don't want
                 // create the child objects multiple times.
+                if (debug)
+                    std::cout << "Check Refresh Object Timer is enabled?"
+                              << "\n";
                 if (!refreshObjectTimer->isEnabled())
                 {
                     // if start timer throws exception then let the application
                     // crash
+                    if (debug)
+                        std::cout
+                            << "Call Restart Once with a Timeout seconds:"
+                            << std::chrono::seconds(refreshTimeout).count()
+                            << "\n";
+
                     refreshObjectTimer->restartOnce(refreshTimeout);
                 } // end if
             }     // end if
@@ -89,6 +149,16 @@ static int eventHandler(sd_event_source* /*es*/, int fd, uint32_t /*revents*/,

     } // end while

+    if (debug)
+    {
+        std::cout << "RTNETLINK Event Handler completed read of packets and "
+                     "processed it"
+                  << " with an length(exit):" << len << "\n";
+
+        if (errno)
+            std::cout << "Error Number:" << errno << "\n";
+    }
+
     return 0;
 }

--
2.17.1

