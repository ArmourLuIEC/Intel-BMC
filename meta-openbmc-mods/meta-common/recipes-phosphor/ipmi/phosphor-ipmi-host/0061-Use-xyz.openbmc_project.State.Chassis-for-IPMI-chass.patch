From 514b76d1c05d7ed7fb7e1df27833e423e04c9a1c Mon Sep 17 00:00:00 2001
From: "Jason M. Bills" <jason.m.bills@linux.intel.com>
Date: Tue, 21 May 2019 09:57:16 -0700
Subject: [PATCH] Use xyz.openbmc_project.State.Chassis for IPMI chassis status

Instead of directly using pgood on dbus, this change uses the
xyz.openbmc_project.State.Chassis "CurrentPowerState" property
for the IPMI chassis status command.  This will allow us to
remove pgood from dbus.

Tested:
Ran IPMI chassis commands and confirmed that they behave as
expected:
ipmitool power status
Chassis Power is on

ipmitool power off
Chassis Power Control: Down/Off

ipmitool power status
Chassis Power is off

ipmitool power on
Chassis Power Control: Up/On

ipmitool power status
Chassis Power is on

Change-Id: I7836c16b76c3b309f176186f3e2453082e4cd1af
Signed-off-by: Jason M. Bills <jason.m.bills@linux.intel.com>
---
 chassishandler.cpp | 61 ++++++++++++++++++++++++++++++++++++------------------
 1 file changed, 41 insertions(+), 20 deletions(-)

diff --git a/chassishandler.cpp b/chassishandler.cpp
index 1738ccc..e4e842d 100644
--- a/chassishandler.cpp
+++ b/chassishandler.cpp
@@ -824,44 +824,65 @@ std::optional<uint2_t> getPowerRestorePolicy()
  */
 std::optional<bool> getPowerStatus()
 {
-    constexpr const char* powerControlObj =
-        "/xyz/openbmc_project/Chassis/Control/Power0";
-    constexpr const char* powerControlIntf =
-        "xyz.openbmc_project.Chassis.Control.Power";
     bool powerGood = false;
     std::shared_ptr<sdbusplus::asio::connection> busp = getSdBus();
     try
     {
+        constexpr const char* chassisStatePath =
+            "/xyz/openbmc_project/state/chassis0";
+        constexpr const char* chassisStateIntf =
+            "xyz.openbmc_project.State.Chassis";
         auto service =
-            ipmi::getService(*busp, powerControlIntf, powerControlObj);
+            ipmi::getService(*busp, chassisStateIntf, chassisStatePath);
 
-        ipmi::Value variant = ipmi::getDbusProperty(
-            *busp, service, powerControlObj, powerControlIntf, "pgood");
-        powerGood = static_cast<bool>(std::get<int>(variant));
+        ipmi::Value variant =
+            ipmi::getDbusProperty(*busp, service, chassisStatePath,
+                                  chassisStateIntf, "CurrentPowerState");
+        std::string powerState = std::get<std::string>(variant);
+        if (powerState == "xyz.openbmc_project.State.Chassis.PowerState.On")
+        {
+            powerGood = true;
+        }
     }
     catch (const std::exception& e)
     {
         try
         {
-            // FIXME: some legacy modules use the older path; try that next
-            constexpr const char* legacyPwrCtrlObj =
-                "/org/openbmc/control/power0";
-            constexpr const char* legacyPwrCtrlIntf =
-                "org.openbmc.control.Power";
+            // FIXME: some modules use pgood; try that next
+            constexpr const char* powerControlObj =
+                "/xyz/openbmc_project/Chassis/Control/Power0";
+            constexpr const char* powerControlIntf =
+                "xyz.openbmc_project.Chassis.Control.Power";
             auto service =
-                ipmi::getService(*busp, legacyPwrCtrlIntf, legacyPwrCtrlObj);
+                ipmi::getService(*busp, powerControlIntf, powerControlObj);
 
             ipmi::Value variant = ipmi::getDbusProperty(
-                *busp, service, legacyPwrCtrlObj, legacyPwrCtrlIntf, "pgood");
+                *busp, service, powerControlObj, powerControlIntf, "pgood");
             powerGood = static_cast<bool>(std::get<int>(variant));
         }
         catch (const std::exception& e)
         {
-            log<level::ERR>("Failed to fetch pgood property",
-                            entry("ERROR=%s", e.what()),
-                            entry("PATH=%s", powerControlObj),
-                            entry("INTERFACE=%s", powerControlIntf));
-            return std::nullopt;
+            try
+            {
+                // FIXME: some legacy modules use the older path; try that next
+                constexpr const char* legacyPwrCtrlObj =
+                    "/org/openbmc/control/power0";
+                constexpr const char* legacyPwrCtrlIntf =
+                    "org.openbmc.control.Power";
+                auto service = ipmi::getService(*busp, legacyPwrCtrlIntf,
+                                                legacyPwrCtrlObj);
+
+                ipmi::Value variant =
+                    ipmi::getDbusProperty(*busp, service, legacyPwrCtrlObj,
+                                          legacyPwrCtrlIntf, "pgood");
+                powerGood = static_cast<bool>(std::get<int>(variant));
+            }
+            catch (const std::exception& e)
+            {
+                log<level::ERR>("Failed to fetch pgood property",
+                                entry("ERROR=%s", e.what()));
+                return std::nullopt;
+            }
         }
     }
     return std::make_optional(powerGood);
-- 
2.7.4

