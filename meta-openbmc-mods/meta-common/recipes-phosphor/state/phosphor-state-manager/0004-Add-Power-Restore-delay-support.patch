From 0edff651156ae63b6a73d9cb81e5e76cc6ae501a Mon Sep 17 00:00:00 2001
From: Yong Li <yong.b.li@linux.intel.com>
Date: Fri, 12 Apr 2019 18:43:06 +0800
Subject: [PATCH] Add Power Restore delay support

That takes effect whenever the BMC
automatically turns on the system due
to the Power Restore Policy setting

Tested:
Set power restore delay:
ipmitool raw 0x30 0x54 0 7
Set restore policy as always-on:
ipmitool chassis policy always-on
AC off/on, check the journal log, the host will start boot after 7 seconds delay

Signed-off-by: Yong Li <yong.b.li@linux.intel.com>
---
 discover_system_state.cpp | 71 +++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 68 insertions(+), 3 deletions(-)

diff --git a/discover_system_state.cpp b/discover_system_state.cpp
index 0b5798a..298ae5b 100644
--- a/discover_system_state.cpp
+++ b/discover_system_state.cpp
@@ -1,5 +1,4 @@
 #include <getopt.h>
-#include <iostream>
 #include <map>
 #include <string>
 #include <config.h>
@@ -114,6 +113,49 @@ void setProperty(sdbusplus::bus::bus& bus, const std::string& path,
     return;
 }
 
+int getPowerRestoreDelay(sdbusplus::bus::bus& bus, uint16_t& delay)
+{
+    static constexpr const char* powerRestoreDelayObjPath =
+        "/xyz/openbmc_project/control/power_restore_delay";
+    static constexpr const char* powerRestoreDelayIntf =
+        "xyz.openbmc_project.Control.Power.RestoreDelay";
+    static constexpr const char* powerRestoreDelayProp = "PowerRestoreDelay";
+
+    std::string service =
+        getService(bus, powerRestoreDelayObjPath, powerRestoreDelayIntf);
+
+    sdbusplus::message::message method = bus.new_method_call(
+        service.c_str(), powerRestoreDelayObjPath, PROPERTY_INTERFACE, "Get");
+
+    method.append(powerRestoreDelayIntf, powerRestoreDelayProp);
+
+    try
+    {
+        auto reply = bus.call(method);
+        sdbusplus::message::variant<uint16_t> variant;
+        reply.read(variant);
+        delay = sdbusplus::message::variant_ns::get<uint16_t>(variant);
+    }
+    catch (sdbusplus::exception_t&)
+    {
+        phosphor::logging::log<phosphor::logging::level::ERR>(
+            "Failed to get property",
+            phosphor::logging::entry("PROPERTY=%s", powerRestoreDelayProp),
+            phosphor::logging::entry("PATH=%s", powerRestoreDelayObjPath),
+            phosphor::logging::entry("INTERFACE=%s", powerRestoreDelayIntf));
+        return -1;
+    }
+    return 0;
+}
+
+void applyPowerRestoreDelay(uint16_t delay)
+{
+    if (delay > 0)
+    {
+        log<level::INFO>("Apply Power Restore Delay", entry("DELAY=%d", delay));
+        std::this_thread::sleep_for(std::chrono::milliseconds(1000 * delay));
+    }
+}
 } // namespace manager
 } // namespace state
 } // namespace phosphor
@@ -176,13 +218,27 @@ int main(int argc, char** argv)
     log<level::INFO>("Host power is off, checking power policy",
                      entry("POWER_POLICY=%s", powerPolicy.c_str()));
 
+    uint16_t delay = 0;
+    int ret = getPowerRestoreDelay(bus, delay);
+
+    if (ret != 0)
+    {
+        log<level::WARNING>("getPowerRestoreDelay failed!");
+        delay = 0;
+    }
+
     if (RestorePolicy::Policy::AlwaysOn ==
         RestorePolicy::convertPolicyFromString(powerPolicy))
     {
+        applyPowerRestoreDelay(delay);
+
         log<level::INFO>("power_policy=ALWAYS_POWER_ON, powering host on");
+
         setProperty(bus, hostPath, HOST_BUSNAME, "RequestedHostTransition",
                     convertForMessage(server::Host::Transition::On));
 
+        // Host on, needs to set the restart cause after host transition
+        // since host transition will change the restart cause
         setProperty(
             bus, hostPath, HOST_BUSNAME, "HostRestartCause",
             convertForMessage(server::Host::RestartCause::PowerPolicyAlwaysOn));
@@ -195,17 +251,26 @@ int main(int argc, char** argv)
         // Read last requested state and re-request it to execute it
         auto hostReqState =
             getProperty(bus, hostPath, HOST_BUSNAME, "RequestedHostTransition");
-        setProperty(bus, hostPath, HOST_BUSNAME, "RequestedHostTransition",
-                    hostReqState);
 
         if (server::Host::convertTransitionFromString(hostReqState) ==
             server::Host::Transition::On)
         {
+            applyPowerRestoreDelay(delay);
+            setProperty(bus, hostPath, HOST_BUSNAME, "RequestedHostTransition",
+                        hostReqState);
+
+            // Host on, needs to set the restart cause after host transition
+            // since host transition will change the restart cause
             setProperty(
                 bus, hostPath, HOST_BUSNAME, "HostRestartCause",
                 convertForMessage(
                     server::Host::RestartCause::PowerPolicyPreviousState));
         }
+        else
+        {
+            setProperty(bus, hostPath, HOST_BUSNAME, "RequestedHostTransition",
+                        hostReqState);
+        }
     }
 
     return 0;
-- 
2.7.4

